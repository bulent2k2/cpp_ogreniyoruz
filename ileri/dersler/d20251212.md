[CSES sitesinden Apple Division adlı problem](https://cses.fi/problemset/task/1623)  
----

Sayı kümesini en iyi şekilde ikiye bölmek için özyineleyen bir işlev yazdık.
[Dersten çözüm burada](https://www.onlinegdb.com/QivsDmT514). Bunda taban olarak `n == 1` koşulunu kullanmıştık. Ama dersten sonra `n == 0` koşuluyla yazdım. Daha da sade ve güzel oldu bence:

```c++
// t1, t2: iki parçanın elemanlarının toplamı
// en başta ikisi de sıfır:
S bul(Kume kume, S t1, S t2) {
    if (kume.size() == 0)
        return abs(t1-t2);
    S s = kume.back(); // kümenin bir elemanını alalım 
    kume.pop_back(); // kümeden çıkaralım 
    S fark1 = bul(kume, t1+s, t2), // ilk parçaya koyarsak nasıl olur
      fark2 = bul(kume, t1, t2+s); // ikinci parçaya koyarsak?
    return min(fark1, fark2);
}

// main() içinde kümeye sayıları ekledikten sonra şöyle çalıştırıyoruz:
bul(kume, 0, 0);
```

[Kodun hepsi burada](https://onlinegdb.com/h_uSetIcx).  Küçük bir örnek için elle çalıştırıp daha iyi anlayabiliriz:

```
küme = { 3, 1, 2 }

bul({ 3, 1, 2 }, 0, 0) {
  // En son eleman 2'yi çıkar ve ilk toplama ekle:
  bul({ 3, 1 }, 2, 0) {
    // şimdi son eleman 1:
    bul({ 3 }, 2+1, 0)
      // şimdi de 3:
      bul({ }, 2+1+3, 0) => fark: 6
      bul({ }, 2+1, 3)   => fark: 0
    bul({ 3 }, 2, 1)
      bul({ }, 2+3, 1)   => fark: 4
      bul({ }, 2, 1+3)   => fark: 2
  }
  // 2'yi ikinci toplama ekle:
  bul({ 3, 1 }, 0, 2) {
    bul({ 3 }, 1, 2)
      bul({ }, 1+3, 2)   => fark: 2
      bul({ }, 1, 2+3)   => fark: 4
    bul({ 3 }, 0, 2+1)
      bul({ }, 3, 2+1)   => fark: 0
      bul({ }, 0, 2+1+3) => fark: 6
  }
}
```

Kümenin boyu 20'den küçük olduğu için özyineleme yerine döngüyle ve sayıların *bit*lerini kullanarak çözmek de mümkün:

```c++
S bul(Kume& küme) {
    K n = küme.size();
    K aks = 1 << n; // alt küme sayısı = 2^n
    S toplam = 0;
    for (auto s: küme) toplam += s;
    
    S fark = toplam; // mümkün olan en büyük fark: alt kümelerden biri boş küme 
    for (K ak = 0; ak < aks; ++ak) { // her alt küme için 
        S t1=0, t2=0;
        for (K k = 0; k < n; ++k) { // her eleman için 
            K bit = 1 << k; // bu elemanı temsil eden bit
            if (ak & bit) // bu eleman bu alt kümenin içinde mi?
                t1 += küme[k]; // alt küme ilk parça 
            else 
                t2 += küme[k]; // geri kalanlar da ikinci parça 
        }
        fark = min(fark, abs(t1-t2));     
    }
    return fark;
}
```
Yine küçük bir örnekle *bit*lerin nasıl işe yaradığını görelim:
```
küme = {3, 1, 2}
   n = 3
 2^n = 8 

Sayı Bitler  Alt küme
---- ------  --------
0    0 0 0   { }
1    0 0 1   { 2 }
2    0 1 0   { 1 }
3    0 1 1   { 1, 2 }
4    1 0 0   { 3 }
5    1 0 1   { 3, 2 }
6    1 1 0   { 3, 1 }
7    1 1 1   { 3, 1, 2 }
```
Bilmem hangisini beğendiniz. İkisini de bilmekte fayda var. [Kodun hepsi burada](https://onlinegdb.com/RIxHA2N10). Gelecek derste üzerinden geçeriz isterseniz.  

Çalışma hızı karmaşıklığı `O(2^n)` yani büyük kümeler için hiç pratik değil. Daha hızlı çözmek mümkün değil mi? Bu çok meşhur `np ve p eşit mi?` adlı probleme dayanıyor. Henüz çözümü bulunamadı. Ama çoğunluk eşit olmadığını düşünüyor. [Daha detaylı bilgiler 
burada](../sayi-kumesini-ikiye-bolmek.md).

Bir setin bütün alt kümelerini nasıl üretiriz
----
Alt küme üreten özyinelemeli bir işlev yazdık. [Kod burada](https://www.onlinegdb.com/Mc4PKrHHv8). Bu tekniğin genel adı *backtracking* yani geri dönüşlerle yapılan arama. Tümevarım yöntemi gibi yoktan başlıyor ve bir altküme üretince geri dönüp başka bir altküme üretiyor. Derste bir arkadaşınız döngüyle yapamaz mıyız acaba diye sordu. Dersten sonra araştırmış ve bulmuş sağolsun. Sanırım yukarıdaki not da soruya yanıt olmuş oldu. Gelecek derste tartışalım biraz isterseniz.  

En son da işlev kalıbı (*template function*) kullanarak daha genel bir çözüm oluşturduk. [Onun kodu da burada](https://www.onlinegdb.com/yjTH4nC06).  
