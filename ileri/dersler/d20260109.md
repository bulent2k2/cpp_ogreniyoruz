[Hamilton patikaları](https://cses.fi/problemset/task/1625) 
---
Önce çizge kuramının meşhur problemine baktık. Bütün patikaları yavaş da olsa bulan [kodumuzun](https://onlinegdb.com/RaoWafa6Q) üzerinden geçtik, satır satır. Geçen derslerde gördüğümüz, altküme ve permütasyon üretme algoritmalarına çok benziyor. Yine ileri gidip geri dönerek arama (*backtracking*) da denilen, derinlemesine gezi tekniğini kullanıyor. Bu zor problemde 6x6 ve daha küçük tahtalar için hızlı çalışıyor ama 7x7 için dakikalar sürüyor. Siz de en baştan ve ezberden yazıverin, daha iyi pekişsin ve iyice anlaşılsın.

Genel çizgeler kuramının en zor ve henüz çözülememiş problemlerinden biri: büyük bir çizgede bütün noktalardan sadece bir kere geçen bir patika bulmanın doğrusal hatta polinom hızda bir çözümü olması mümkün görünmüyor. 

Arama uzayının nasıl büyüdüğünü inceledik ve dedik ki ciddi bir budama yaparak hızlandırmak gerekli ki bir saniyede çalışsın. Yoksa *cses.fi* sitesinde başarılı olmayacak. Bunun için bir ipucundan bahsettik: Diyelim ki `x,y` karesine geldik ve komşularına bakıyoruz. Eğer hem üst hem de alt komşuları (yani `x,y-1` ve `x,y+1` kareleri) patikada daha önce ziyaret edilmişse,  ama aynı zamanda hem sağ hem de sol komşuları (yani `x-1,y` ve `x+1,y` kareleri) patikada değilse, çıkmaz bir yola girmiş demektir (bunu kanıtlamak iyi olur). Onun için artık ileri gitmeyelim, geri dönelim. Benzer şekilde, sağ ve sol komşuları patikada, ama üst ve alt komşular henüz patika üzerinde değilse, o durumda da budayabiliyoruz arama uzayını. Bu iki durumu kodumuza eklemek sizlere ufak bir alıştırma olsun. 

Bozuk paralar ve Kağıt desteleri
---

Cebimizde bir miktar para var. Onlarla harcama yaparken para üstü gerektiren en küçük fiyatı nasıl bulabiliriz? [*Missing coin sum*](https://cses.fi/problemset/task/2183/) adlı problem bu. Bu soru için birlikte bir kod yazdık. Sade, güzel ve sürpriz bir çözüm oldu. Neden doğru çalıştığını kanıtlamak iyi bir alıştırma olur, isteyenler için. [Kodumuz burada](https://onlinegdb.com/b8pb6RLKH).

Elimizde karıştırılmış bir kart destesi olsun. Sırayla üzerinden geçme koşuluyla, kartları birden başlayarak toplamak istiyoruz. Kaç kere bütün kartları taramamız gerekir? Bu problemin adı da [*Collecting numbers 1*](https://cses.fi/problemset/task/2216).

Bunun için nasıl bir çözüm olacağını konuştuk. Doğrusal hızla çözülebilir olduğundan bahsettik. Bazı arkadaşlarınız çözüm için kod yazdılar bile. Hepiniz için iyi bir alıştırma olur. 

Arkasından da yine karıştırılmış `n` tane kart olan bir desteyle başlıyoruz ama, verilen iki konumdaki kartların yerleri değiştiriliyor arka arkaya, hem de bir çok kere. Bu değişikliklerin sayısı`m` olsun. Eğer hep en baştan hesaplamak istersek`O(n*m)` hızında çalışıyor, bu da hem `n` hem de `m` büyük olabileceği için karesel karmaşıklıkla yani epey yavaş çalışıyor. Onun yerine istenen değişikliğin etkisini bulup büyük toplama eklersek çok daha hızlanacak. Problemin adı [*Collecting numbers 2*](https://cses.fi/problemset/task/2217). Bu da güzel bir alıştırma olur. Ama ufak bir zorluk daha var: Değiştirilen kartların konumları `k1` ve `k2` olsun. Örneğin:
```
k1 k2   kartlar    tarama sayısı
-- --   -------    -------------
        4 2 1 5 3      3
2  3    4 1 2 5 3      2
1  5    3 1 2 5 4      3
2  3    3 2 1 5 4      4
```
`k1, k2` konumlarındaki iki sayı `a, b` olsun. Tarama sayısındaki değişmeyi bulmak için şu çiftlerin sırasına bakmak yetiyor:
`(a-1 a), (a a+1), (b-1 b), (b b+1)`
Yani bütün kartlara bakmaya gerek yok. Ama dikkat etmemiz gereken bir durum var:    
`a+1 == b-1` ya da `a+1 == b`olabilir! Hatta `a == b`de olabilir! Yanlış saymamak için koşullar eklemeli. Ya da
 `a-1, a, a+1, b-1, b, b+1` sayılarını bir kümeye (yani `std::set`'e) koyup sadeleştirebiliriz. Kolay ve keyifli gelsin!

> Sağolsun [StackEdit](https://stackedit.io/)'i icat eden mühendis ve programcılar.