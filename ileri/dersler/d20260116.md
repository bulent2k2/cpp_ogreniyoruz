Arama uzayını budalamak
----

[Geçen dersimizde](d20260109.md) *arama uzayını* derinlemesine gezen bir program taslağı üzerinden geçmiştik. 
[Hamilton patikalarının](https://cses.fi/problemset/task/1625) hepsini buluyordu ama epey yavaştı. 
Bu derste aramayı çok hızlandıran bir budama kodladık.
Şu satırları ekleyerek çıkmaz sokaklarda gezinmesini ve boşa zaman harcamasını önledik:
```c++
bool so=gir[y][x-1], sa=gir[y][x+1],
     yu=gir[y-1][x], aş=gir[y+1][x];
if (yu and aş and not(so or sa) or
    so and sa and not(yu or aş)) return;
```
Arama uzayını çok dallı budaklı bir ağaç gibi düşünelim. Meyve vermeyen dalları budamak elbet çok faydalı oluyor. 
Ama budadığımız dalların meyve veremeyeceğinden de emin olmak gerek. Yoksa meyveler boşa gider. Yanı bir kanıt gerek. 
Bu kanıt pek zor değil. Kağıt kalemle birkaç örnek çizerek kendinizi ikna edin, olur mu? 
Çözüm için [yazdığımız kodun hepsi burada](https://onlinegdb.com/f6BJ1j1UG).

Karışık bir destenin kartlarını sıralamak
----

Geçen derste giriş yaptığımız iki deste kağıt sorusuna devam ettik. [Birincisi](https://cses.fi/problemset/task/2216) için çözüm kodunu beraber yazdık. Kısacık ve şaşırtıcı kodun hepsini tekrar görelim:
```c++
using S=unsigned; using K=S;
#include <iostream>
int main() {
    S n; // destenin uzunluğu
    K *sıra; // her kartın deste içindeki sırası ya da konumu
    std::cin >> n;
    sıra = new K[n+1]; // 0. kart yok, boş kalsın
    for(K k=1; k<=n; ++k) {
        S kart;
        std::cin >> kart;
        sıra[kart] = k;
    }
    S kere=1; // 1. kartı bulmak için bir kere geçmek gerek bütün destenin üzerinden
    for(S kart=1; kart<n; ++kart)
        if (sıra[kart] > sıra[kart+1]) ++kere;
    std::cout<<kere;
    delete [] sıra;
    return 0;
}
```
Ufak tefek değişiklikler yaptım ki tür ve değişken adları biraz daha doğru olsun. Ama önemli olan iki püf noktası şu satırlar:
1. `sıra[kart] = k` Yani her bir kartı girdi olarak okuduktan hemen sonra deste içindeki sırasını ya da konumunu dizinin içine yazıyoruz.
2. `sıra[k] > sıra[k+1]` Örneğin `k=1` olsun. Eğer `1` kartı destede `2` kartından daha sonra geliyorsa, 
en azından bir kere daha taramamız gerek. Aynı koşul `n`den küçük bütün `k`lar için geçerli elbet.

Deste ne kadar uzun olursa olsun, kodumuz doğrusal hızda yani `O(n)` çalışıyor. Daha hızlı olması mümkün değil.
Onlinegdb'de çalıştırıp test etmek için [kodun hepsi burada](https://onlinegdb.com/TFHzHouhh).

[Bunu izleyen soru](https://cses.fi/problemset/task/2217) da yine aynı algoritmayla çözülebilir dedik ve onun kodunu yazdık.
`vector` yerine sade dizi kullanarak ve `swap` yerine açık açık iki değişkenin değerlerini değiştirerek de yazabiliriz:
```c++
using S=unsigned; using K=S;
#include <iostream>
int main() {
    S n, m; // destenin uzunluğu, komut sayısı
    K *sıra; // her kartın deste içindeki sırası ya da konumu
    S *kart; // sırasından kartı bulma
    std::cin >> n >> m;
    sıra = new K[n+1]; // 0. kart yok, boş kalsın
    kart = new S[n+1]; // 0. sırada kart olmasın
    for(K k=1; k<=n; ++k) {
        std::cin >> kart[k];
        sıra[kart[k]] = k;
    }
    while(m-- > 0) {
        K k1, k2;
        std::cin >> k1 >> k2;
        S x, &a = kart[k1], &b = kart[k2];
        x = a; a = b; b = x;
        x = sıra[a]; sıra[a] = sıra[b]; sıra[b] = x;
        S kere=1; 
        for(S kart=1; kart<n; ++kart)
            if (sıra[kart] > sıra[kart+1]) ++kere;
        std::cout<<kere<<'\n';
    }
    delete [] sıra;
    delete [] kart;
    return 0;
}
```
[Onlinegdb kodu ve testleri de burada](https://onlinegdb.com/kA_xtEXSMK).
Bu problemi doğru çözüyor ama epey yavaş çalışabiliyor. Çünkü çalışma süresi `O(n*m)` yani karesel boyutta. 
Geçen derste hızlandırmak için bir yöntem incelemiştik. Onun kodunu da yazdık birlikte ve neredeyse bitiriyorduk ama vakit yetmedi.
Kaldığımız nokta şöyle bir yerdi. Ama ufak tefek değişiklikler yaptım işi kolaylaştırmak için:
```c++
using S=unsigned; using K=S;
#include <vector>
S n;
std::vector<K> sk;   // s->k sayının deste içindeki konumu
S katkı(S s1, S s2);
#include <algorithm> // std::swap
#include <iostream>
int main() {
    S m;
    std::cin >> n >> m;
    sk.resize(n+2); // +2'ye dikkat
    std::vector<S> ks(n+1); // k->s konumdan sayıya.
    for(K k=1; k<=n; ++k) {
        std::cin >> ks[k];
        sk[ks[k]] = k;
    }
    sk[n+1] = n+1; // Neden?? Bir de zaten: sk[0]=0
    S kere=1;
    for(K k=1; k<n; ++k)
        if (sk[k]>sk[k+1])++kere;
    while(m-- > 0) {
        K k1, k2;
        std::cin >> k1 >> k2;
        S &s1 = ks[k1],
          &s2 = ks[k2];
        S kOnce = katkı(s1,s2);
        std::swap(sk[s1], sk[s2]);
        std::swap(s1, s2);
        S kSonra = katkı(s1,s2);
        kere += (kSonra - kOnce);
        std::cout<<kere<<'\n';
    }
    return 0;
} 
S katkı(S a, S b) {
    S kat=0;
    if (sk[a-1] > sk[a]) ++kat;
    if (sk[a] > sk[a+1]) ++kat;
    if (sk[b-1] > sk[b]) ++kat;
    if (sk[b] > sk[b+1]) ++kat;
    return kat;
}
```
`katkı` işlevi bazen fazla fazla sayıyor. Örneğin `a+1==b` olursa.
Nasıl düzeltmeli? [Onlinegdb kodu ve testleri burada](https://onlinegdb.com/S96HCF7c1). 
Birkaç değişik yöntem mümkün. Size ufak bir alıştırma olsun. Biraz kafa yorun, olur mu?
Örnek olarak [tam bir çözüm de burada](https://onlinegdb.com/hltrNS4Dt). Ama geçen derste söylemiştik, `std::set` kullanarak da çözebilirdik. 
Doğru çözümü [CSES.fi](https://cses.fi/) sitesine girerseniz, daha değişik ve epey güzel bir çözüm daha göreceksiniz. 
Hem de lambda (adsız) işlev kullanıyor.
