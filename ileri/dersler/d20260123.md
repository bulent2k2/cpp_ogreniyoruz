Çizge problemleri için temel algoritmalar
===

[Kaç tane oda var?](https://cses.fi/problemset/task/1192)
---

Geçen derste Hamilton patikalarının hepsini hızla bulan bir algoritma yazmıştık. Bu derste de çok benzer bir kalıp kullandık. Duvarları gösteren bir kat planı okuyup odaları sayan bir çözümü dikkatle okuduk inceledik. Epeydir örneklerini gördüğümüz DFS (*depth first search*) adlı *derinlemesine arama* kalıbıyla oldukça güzel çözüldü. Dersten sonra ufak tefek iyileştirmeler yaptım ve sadeleştirdim. [Son durum burada](https://onlinegdb.com/J66ODx1Mi). Daha önceki hallerini hatırlamak isterseniz:
1. [Duvarsız hali burada](https://cses.fi/paste/a46bc98e697a86a7eeacc6/). Epey sade ama çevresini duvarla çevirmediğimiz için bazı testler hata verdi.
2. [Duvarlı tam çözüm burada](https://onlinegdb.com/uFPKtAsq1).
3. Akıllı dizi (`std::vector`) kullanınca daha da sadeleşiyor. [O da burada](https://onlinegdb.com/iqh2iYL5X).
Bu faydalı deseni tekrar görelim ve iyice öğrenelim:
```c++
using Tahta = Dizi<Dizi<bool>>;
bool gez(K y, K x, Tahta& t) {
    if (not t[y][x]) // müsait mi?
        return false;
    t[y][x] = false; // artık müsait değil
    gez(y-1, x, t);
    gez(y+1, x, t);
    gez(y, x-1, t);
    gez(y, x+1, t);
    return true; // bir oda daha bulduk
}
```
Bu *DFS* yöntemine aynı zamanda neden *backtracking* yani en dibine kadar gidip geri dönüşlerle yapılan arama türü demişler daha iyi anladık umarım.

[Labirentte en kısa yol tarifi](https://cses.fi/problemset/task/1193)
---
İkinci problem yine bir tahta üzerinde verilen iki nokta arasındaki en kısa yollardan birini bulmak ve tarifini yapmak. Bunu da bir kat planı gibi düşünebiliriz. Bir odadan başka bir odaya gitmek için en kısa yolu bulduk. Ama bu sefer DFS yerine BFS (*breath first search*) yani enlemesine arama algoritması kullandık. Bunu yapmanın çok yaygın yöntemlerinden birini gördük. `while` döngüsü içinde `std::queue` veri yapısı kullandık.

[Benim ilk çözümüm burada](https://cses.fi/paste/5ce23ecd10c97b1feed1a4/). Ama daha sonra üzerinden geçip sadeleştirmeler yapmıştım. Son halinin üzerinden geçtik birlikte. [O da burada](https://onlinegdb.com/FTqzamnFH). İkisi de çalıştı ve tam not aldı. Ama biraz ilgi ve sevgiyle 93 satırdan 69 satıra düştü. Önemli mi? Ne farkeder? Bence böyle iyileştirmeler ve sadeleştirmeler (*refactoring*) epey önemli. Hem yazdığımız programları okumak ve anlamak kolaylaşıyor hem de sağlam ve güvenilir mühendislik yolunda bir adım atmış oluyoruz. Bakın ben dayanamadım biraz daha sadeleştirdim bu notları yazarken: [birazcık uzadı ama daha anlaşılır ve sade oldu umarım](https://onlinegdb.com/82icSqJFE). Hatta biraz daha [güzeli de burada](https://onlinegdb.com/LJhDTsTdG). Önemli kısmı akıllı dizi kalıbına `Dizi` adı vermek, `Bilgi` adlı türümüzü anlatmak ve `Tahta` adlı türümüzü sadeleştirmek oldu:
```c++
#include <vector>
template <class Tür>
using Dizi=std::vector<Tür>;

struct Bilgi { 
    bool yol;  // müsait mi?
    char adım; // buraya nereden geldik (sol, sağ, yukarı ya da aşağı komşudan biri)
};
const Bilgi yol   {true, '.'},
            duvar {false, '#'};
            
using Tahta=Dizi<Dizi<Bilgi>>;
// ...
Tahta tahta(n+2, Dizi<Bilgi>(m+2, duvar));
// ...
Bilgi & bilgi = tahta[y+1][x+1];
bilgi = yol;
```
Ne dersiniz daha anlaşılır olmamış mı? Tabii bu arada önemli *BFS* yani enlemesine arama kalıbını da yine görelim:
```c++
#include <queue>
struct Oda { K y, x; } A, B;  // A'dan B'ye en kısa yol tarifi
using Kuyruk   = std::queue<Oda>;
using Komşu    = std::pair<Oda, char>;
using Komşular = Dizi<Komşu>;

bool bul(Tahta & t) {
    Kuyruk kuyruk;
    kuyruk.push(A);
    while (not kuyruk.empty()) {
        auto [y, x] = kuyruk.front(); 
        kuyruk.pop();
        if (x == B.x and y == B.y) return true;  // vardık!
        Komşular komşular = { { {y-1, x}, 'U' }, { {y+1, x}, 'D' },
                              { {y, x-1}, 'L' }, { {y, x+1}, 'R' } };
        for(auto [oda, yön]: komşular)
            if (t[oda.y][oda.x].yol) {
                kuyruk.push(oda); 
                t[oda.y][oda.x] = {false, yön}; // en kısa yol!
            }
    }
    return false; // yol yok!
}
```
Bunu iyice anlayalım, olur mu? Yoksa, sorularınızı bekliyorum. 

Çizge algoritması dedik bunlara ama çizgenin bağlantılarını açık açık belleğe yazan bir veri yapısı gerekmedi. Tahtadaki karelerin ve kat planındaki odaların komşuluğu çok düzenli ve belli. Etrafı engel ve duvarla çevirmek de işi iyice kolaylaştırdı.

Gelecek hafta yine temel ve epey faydalı olan, bir çizgenin bağlı parçalarını bulma algoritmasına bakacağız. Bu sefer daha genel çizgelerle uğraşacağız. Çünkü arasında [yol olmayan şehirleri birbirlerine bağlamak](https://cses.fi/problemset/task/1666) istiyoruz. Ama en makul şekilde. Gereksiz asfalt harcamadan. Onun için çizgeyi, bir veri yapısıyla açıkça belleğe kaydedeceğiz ve oradan kullanacağız. Gelecek derse kadar beklemek istemeyenler için [örnek bir çözüm burada](https://cses.fi/paste/f7497d3026d97d06f446ca/). Üzerinden geçer iyice anlarız birlikte inşallah.

> [StackEdit](https://stackedit.io/) kullanarak yazıldı.
