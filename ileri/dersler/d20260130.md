Yol ağı tasarımı
===

Bu derste çizge kuramının en faydalı problemlerinden birini gördük: bir çizgenin *parçalarını* bulmak. *Bağlı parça* da denir (*connected components*). 

Adı yol yapımı (*building roads*) olan soruyu çözdük. [Yol ağı tasarımı](https://cses.fi/problemset/task/1666) demek daha doğru olur. 

Çözümün ama fikrini şöyle özetleyebiliriz: Çizgeye, bağlı parçalarının sayısı bire düşene kadar yeni çizgiler (yani yollar) ekliyoruz. Onun için de önce bağlı parçaları bulduk. Her şehri ziyaret etmek için bir döngüyle başlıyoruz. Herhangi bir şehir henüz bir parça içinde değilse, yeni bir parça bulmuşuz demektir. O şehirden başlayarak derinlemesine geziyle vardığımız bütün şehirleri aynı parçaya ekliyoruz (alıştırma olarak enlemesine gezi kullanın). İki parçayı bağlarsak, parça sayısı bir azalıyor. İki parça içindeki hangi iki noktayı bağladığımızın bir önemi yok. Her parçayı bir kök olarak ele alalım. O köklerin bir ağacını oluşturursak, soru çözülmüş olacak.

Bağlı parçaları bulmak *O(n+m)*. Kökleri bağlamak da *O(n)* (Neden?). Yani epey hızlı çalışan bir algoritmamız oldu.

Bu derinlemesine geziyi `while` döngüsü ve `std::stack` kalıbı kullanarak yazdık: 
```c++
template <typename T>
using Dizi=std::vector<T>; // bu kalıbı birkaç kere kullanacağız aşağıda..
using Çizge=Dizi<Dizi<S>>; // Çizge (Graph) türü
using PD=Çizge; // bir dizi parçanın türü (parça: çizgenin nokta altkümesi (connected component))

PD parçalar(const Çizge& çzg) { // bağlı parçaları derinlemesine geziyle bulalım    
    PD pd;    
    Dizi<bool> göründü(çzg.size());    
    for (S i = 0; i < çzg.size(); ++i) {        
        if (göründü[i]) continue;        
        Dizi<S> bu={i}; // ilk nokta ilk parçada        
        std::stack<S> tepe; // tepeleme..        
        tepe.push(i); // en son eklenenler önce çıkar (kuyruk olsa, en son eklenen en son çıkar)        
        göründü[i] = true;        
        while (not tepe.empty()) {            
            S v = tepe.top(); tepe.pop();            
            for (S u : çzg[v]) {                
                if (göründü[u]) continue;                
                göründü[u] = true;                
                tepe.push(u);                
                bu.push_back(u);            
            }        
        }        
        pd.push_back(bu);
    }    
    return pd;
}
```
Dersten önce yolladığım [örnek çözüm burada](https://cses.fi/paste/f7497d3026d97d06f446ca/). Derste [üzerinden geçtiğimiz kod da burada](https://onlinegdb.com/on4oQBQZE).
 
Aynı algoritmayı özyineleyerek yazmak da mümkün:

```c++
#include <iostream>
#include <vector>
using S=unsigned;
std::vector<std::vector<S>> çizge; // çizge[nokta]: noktanın komşuları (komşu dizisi)
std::vector<S> parça;              // parça[nokta]: bu noktanın içinde oldugu parçanın kimlik no'su
void parçaya_ekle(S nokta, S parçaKimlikNo) {
    if (parça[nokta]) return;  
    parça[nokta] = parçaKimlikNo;
    for (S n2 : çizge[nokta])        
        parçaya_ekle(n2, parçaKimlikNo);
}

int main() {
    S n, m;
    std::cin >> n >> m;    
    çizge.resize(n+1);    
    parça.resize(n+1);   
    while (m-- > 0) {        
        S a, b;        
        std::cin >> a >> b;        
        çizge[a].push_back(b);        
        çizge[b].push_back(a); 
    }
    S parça_sayısı = 0;    
    std::vector<S> kök; // her parçanın bir temsilcisi olsun: kök[2]: üçüncü parçayı temsil eden nokta(yani şehir)    
    for (S nokta = 1; nokta <= n; ++nokta)         
        if (not parça[nokta]) {            
            parçaya_ekle(nokta, ++parça_sayısı);              
            kök.push_back(nokta);          
        }    
    std::cout << parça_sayısı - 1 << '\n';
    using K = unsigned;    
    for (K k = 0; k + 1 < kök.size(); ++k)        
        std::cout << kök[k] << ' ' << kök[k + 1] << '\n';
    return 0;
}
```

Gelecek dersimizde benzer bir soru daha çözelim, çizge algoritmaları iyice pekişsin, ne dersiniz? 

Büyük bir bilgisayar ağında, *A* bilgisayarından *B* bilgisayarına mesaj yollamak istiyoruz. En kısa patikayı nasıl bulabiliriz? [E-posta yolu (*message routing*) sorusunu buradan okuyabilirsiniz](https://cses.fi/problemset/task/1667). 

> [StackEdit](https://stackedit.io/) kullanarak yazdım.
> 
