[İki takım kurmak](https://cses.fi/problemset/task/1669)
====

Bir sınıf öğrenciyi iki takıma böleceğiz. Takımlar farklı büyüklükte olabilir.
Ama arkadaşlar farklı takımda olmalı. Yani iki öğrenci arkadaşsa karşı takımlarda olmalarını istiyoruz.

Derste bahsetmedik ama bu soru bir çizgenin **bipartite** olup olmadığını bulmaya denk geliyor. 
Türkçe wikide *[iki parçalı graf](https://tr.wikipedia.org/wiki/%C4%B0ki_par%C3%A7al%C4%B1_graf)* diyenler olmuş. 
İki parçayla kasıt bütün noktaları iki altkümeye ayırıyoruz ama 
altküme içindeki noktaların arasında hiç bağ olmaması gerekiyor. 
[İngilizce wikide](https://en.wikipedia.org/wiki/Bipartite_graph) daha çok bilgi ve örnek var.

Derinleme geziyle çözebiliriz dedik ve `std::stack` kullanmak yerine özyineleyen bir işlev yazdık:
```c++
using Arkadaş = unsigned;
#include <vector>
using Arkadaşlar = std::vector<Arkadaş>;
std::vector<Arkadaşlar> sınıf;
using Takım = unsigned; // 0 (henüz bir takıma dahil edilmedi), 1 ya da 2 
std::vector<Takım> takım;
bool dgez(Arkadaş a) { // varsayım: a bir takıma konmuş olmalı (a != 0)
    Takım at = takım[a];
    Takım bt = 3 - at;
    for(Arkadaş b : sınıf[a]) {
        if (takım[b] > 0) {
            if (takım[b] == at) return false;
        } else {   // Hata 1 böyle düzeldi!
            takım[b] = bt;
            if (not dgez(b)) return false;
        }
    }
    return true; // olur
}
#include <iostream>
int main() {
    int n, m;
    std::cin >> n >> m; 
    sınıf.resize(n+1);
    takım.resize(n+1);
    while (m-- > 0) {
        Arkadaş a, b;
        std::cin >> a >> b;
        sınıf[a].push_back(b);
        sınıf[b].push_back(a);
    }
    for (Arkadaş a=1; a <= n; ++a) {
        if (takım[a] == 0) { // Hata 2 de böyle düzeldi
            takım[a] = 1;
            if (not dgez(a)) { std::cout << "IMPOSSIBLE"; return 0; }
        }
    }
    takım.erase(takım.begin());
    for(Takım t : takım) {
        std::cout << t << " ";
    }
    return 0;
}
```
Kodumuz [testleriyle birlikte burada](https://www.onlinegdb.com/LqO6HQbOQ). Başta çabucak yazdık ama sonra biraz tökezledik. 
Bir iki hata yaptık. Ama bence çok iyi oldu, **debugger**'ı kullanmaya başladık. 
*C* ve *C++* dillerinin efsanevi yazılımı **gdb** ([GNU](https://www.gnu.org/)'nun debugger uygulaması) ile tanıştık. Şu hataları bulmamızda çok yardımcı oldu:  
1.  `dgez()` içindeki `else` koşulu eksikti. Daha önce takıma giren bir arkadaşla karşılaşınca gezmeyi sonlandırmamız gerek. Özyinelemeli işlevlerde taban koşulu olmazsa olmaz!
2. `main()`de `for` döngüsünün içindeki ilk `if` koşulunu unuttuk. Birinci hatada olduğu gibi, daha önce bir takıma konan bir öğrenciyi birinci takıma sokmak ve yeni bir gezi başlatmak yanlış oldu. Peki bu `for` döngüsü hiç olmasa olur mu? Çizgede *kopuk parçalar* olursa olmaz. 

Gelecek derste çizgeler kuramından problemler ve çizgeler üzerinde çalışan algoritmalarla devam edelim mi? İsterseniz bir sonraki [gidiş dönüş problemine](https://cses.fi/problemset/task/1669) bakalım. Yönsüz çizgelerde güzel bir döngü bulmaya çalışalım. Matematiksel dünyadan gerçek dünyaya dokunan hem görsel hem de çok kullanışlı kavramlardan biri çizgeler. İlk uygulamasını merak edenlere, 
[meşhur 7 köprü problemi](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg):     
<img src="resim/konigsberg-kopruleri.png" alt="ufak bir ağ" width="300"/>.  

Sizin de yahu matematik ne işe yarar ki diye merak eden tanıdıklarınız olmuştur. Onlara aşağıdaki resmi göstermeli. *Pi* sayısı `3` olsun, yerçekimi katsayısı da `10` olsun deyince köprünün başına ne geldiğini görmek gerek! :)   
<img src="resim/matematik-ne-ise-yarar.png" alt="pi 3 olsun g de 10" width="300"/>    
