[Ä°ki takÄ±m kurmak](https://cses.fi/problemset/task/1668)
====

Bir sÄ±nÄ±ftaki Ã¶ÄŸrencileri iki takÄ±ma bÃ¶leceÄŸiz. TakÄ±mlar farklÄ± bÃ¼yÃ¼klÃ¼kte olabilir.
Ama arkadaÅŸlar farklÄ± takÄ±mda olmalÄ±. Yani iki Ã¶ÄŸrenci arkadaÅŸsa karÅŸÄ± takÄ±mlarda olmalarÄ±nÄ± istiyoruz.

Derste bahsetmedik ama bu soru bir Ã§izgenin **bipartite** olup olmadÄ±ÄŸÄ±nÄ± bulmaya denk geliyor. 
TÃ¼rkÃ§e wikide *[iki parÃ§alÄ± graf](https://tr.wikipedia.org/wiki/%C4%B0ki_par%C3%A7al%C4%B1_graf)* demiÅŸler. 
Ä°ki parÃ§ayla kasÄ±t bÃ¼tÃ¼n noktalarÄ± iki altkÃ¼meye ayÄ±rÄ±yoruz ama 
altkÃ¼me iÃ§indeki noktalarÄ±n arasÄ±nda hiÃ§ baÄŸ olmamasÄ± gerekiyor. 
[Ä°ngilizce wikide](https://en.wikipedia.org/wiki/Bipartite_graph) daha Ã§ok bilgi ve Ã¶rnek var.

Derinleme geziyle Ã§Ã¶zebiliriz dedik ve `std::stack` yerine Ã¶zyineleme kullandÄ±k:
```c++
using ArkadaÅŸ = unsigned;
#include <vector>
using ArkadaÅŸlar = std::vector<ArkadaÅŸ>;
std::vector<ArkadaÅŸlar> sÄ±nÄ±f;
using TakÄ±m = unsigned; // 0 (henÃ¼z bir takÄ±ma dahil edilmedi), 1 ya da 2 
std::vector<TakÄ±m> takÄ±m;
bool dgez(ArkadaÅŸ a) {
    for(ArkadaÅŸ b : sÄ±nÄ±f[a])
        if (takÄ±m[b]) {
            if (takÄ±m[b] == takÄ±m[a]) return false; 
        } else {   // Hata 1 bÃ¶yle dÃ¼zeldi!
            takÄ±m[b] = 3 - takÄ±m[a];
            if (not dgez(b)) return false;
        }
    return true; // olur
}
#include <iostream>
int main() {
    int n, m;
    std::cin >> n >> m; 
    sÄ±nÄ±f.resize(n+1);
    takÄ±m.resize(n+1);
    while (m-- > 0) {
        ArkadaÅŸ a, b;
        std::cin >> a >> b;
        sÄ±nÄ±f[a].push_back(b);
        sÄ±nÄ±f[b].push_back(a);
    }
    for (ArkadaÅŸ a=1; a <= n; ++a)
        if (not takÄ±m[a]) { // Hata 2 de bÃ¶yle dÃ¼zeldi
            takÄ±m[a] = 1;
            if (not dgez(a)) {
                std::cout << "IMPOSSIBLE";
                return 0;
            }
        }
    takÄ±m.erase(takÄ±m.begin());
    for(TakÄ±m t : takÄ±m)
        std::cout << t << " ";
    return 0;
}
```
Kodumuz [testleriyle birlikte burada](https://www.onlinegdb.com/LqO6HQbOQ). BaÅŸta Ã§abucak yazdÄ±k ama sonra biraz tÃ¶kezledik. 
Bir iki hata yaptÄ±k. Ama bence iyi oldu, **debugger**'Ä± kullanmaya baÅŸladÄ±k. 
*C* ve *C++* dillerinin efsanevi yazÄ±lÄ±mÄ± **gdb** ([GNU](https://www.gnu.org/)'nun [debugger uygulamasÄ±](https://www.sourceware.org/gdb/)) ile tanÄ±ÅŸtÄ±k. Åu hatalarÄ± bulmamÄ±za yardÄ±m etti:  
1.  `dgez()` iÃ§indeki `else` koÅŸulu eksikti. Daha Ã¶nce takÄ±ma giren bir arkadaÅŸla karÅŸÄ±laÅŸÄ±nca gezmeyi sonlandÄ±rmamÄ±z gerek. Ã–zyinelemeli iÅŸlevlerde taban koÅŸulu olmazsa olmaz!
2. `main()` iÃ§indeki ilk `for` dÃ¶ngÃ¼sÃ¼nÃ¼n ilk `if` koÅŸulu eksikti. Birinci hatada olduÄŸu gibi, daha Ã¶nce bir takÄ±ma konan bir Ã¶ÄŸrenciyi birinci takÄ±ma sokmak ve yeni bir gezi baÅŸlatmak yanlÄ±ÅŸ oldu. Peki bu `for` dÃ¶ngÃ¼sÃ¼ hiÃ§ olmasa olur mu? Ã‡izgede *kopuk parÃ§alar* varsa olmaz. 

Gelecek derste Ã§izgeler kuramÄ±ndan problemler ve Ã§izgeler Ã¼zerinde Ã§alÄ±ÅŸan algoritmalarla devam edelim mi? Ä°sterseniz bir sonraki [gidiÅŸ dÃ¶nÃ¼ÅŸ problemine](https://cses.fi/problemset/task/1669) bakalÄ±m. YÃ¶nsÃ¼z Ã§izgelerde gÃ¼zel bir dÃ¶ngÃ¼ bulmaya Ã§alÄ±ÅŸalÄ±m. 

Ã‡izgeler, matematiksel dÃ¼nyadan gerÃ§ek dÃ¼nyaya dokunan, hem gÃ¶rsel hem de Ã§ok kullanÄ±ÅŸlÄ± kavramlardan biri. Tarihte ilk uygulamasÄ±nÄ± merak edenler iÃ§in: 
[meÅŸhur 7 kÃ¶prÃ¼ problemi](https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg):     
<img src="resim/konigsberg-kopruleri.png" alt="ufak bir aÄŸ" width="300"/>   

Sizin de "matematiÄŸi iyi bilmesek ne olur" diyen tanÄ±dÄ±klarÄ±nÄ±z olmuÅŸtur. Onlara aÅŸaÄŸÄ±daki resmi gÃ¶stermeli. *Pi* sayÄ±sÄ± `3` olsun, yerÃ§ekimi katsayÄ±sÄ± *g* de `10` olsun diyenlerin yapmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ± kÃ¶prÃ¼nÃ¼n haline bakÄ±n! ğŸ˜Š   
<img src="resim/matematik-ne-ise-yarar.png" alt="pi 3 olsun g de 10" width="300"/>    
