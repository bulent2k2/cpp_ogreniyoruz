
[Canavarlardan kaçış](https://cses.fi/problemset/task/1194/) ve enlemesine geziler
===

Geçen ders, çizgelerde bir *çevrim* bulmak için derinlemesine gezi kalıbını kullanmıştık. Bu kalıbı en sade haliyle tekrar görelim:
```c++ 
void gez(Nokta ) {
    if (gezildi[bu]) return;
    gezildi[bu] = true;
    for (Nokta şu: komşular[bu])
        gez(şu);
}
```
Bu kalıp gerçekten çok sade ve faydalı. Ama sadeliği bizi kandırmasın. Altında zengin bir temel var. Bakalım kaç değişken türü kullanılıyor?
1. `void` Yani `gez` işlevinin çıktısı yok.
2. `using Nokta=unsigned;` Girdisinin türü.
3. `bool` Türkçe'de *ikil* ya da *seçim* diyebiliriz.
4. `std::vector<bool>`. Her `Nokta`'yı bir `seçim`le eşliyoruz.
5. `using Noktalar=std::vector<Nokta>;`
6. `std::vector<Noktalar>` `komşular` dizisinin türü, yani çizgenin hepsi.

Çizgeyi gezmek için özyineleme yerine `std::stack` yani tepeleme adlı veri yapısı ve `while` döngüsüyle adım adım çalışan bir kalıp da kullanabiliriz.
```c++
void gez2(Nokta ilk) {
    if (gezildi[ilk]) return;
    std::stack<Nokta> tepe; // tepeleme ya da yığın
    tepe.push(ilk);
    while(not tepe.empty()) {
        Nokta bu = tepe.top();
        tepe.pop();
        gezildi[bu] = true;
        for (Nokta şu: komşular[bu])
            if(not gezildi[şu])
                tepe.push(şu);
    }
}
```
Satır sayısı iki katından fazla ve daha çok detay var. Dolayısıyla kodu yazarken hata yapma olasılığımız artıyor. Onun için genelde tercihimiz özyineleme yöntemini kullanmak. Ama biliyorsunuz bazı problemlerin çözümünde enlemesine gezinti gerekiyor ve özyinelemeyle nasıl yapılır hiçbir fikrim yok (en altta yapay zekadan aldığım yanıt var). Onun için `gez()` yerine `gez2()` kalıbını da iyi bilmek hatta bellemekte fayda var. Tepeleme yerine kuyruk kullanarak enlemesine geziler yapmıştık daha önce. Bir labirent içinde ve bir bilgisayar ağında en kısa yolları bulmuştuk. Kalıbımız yine görelim:
```c++
void gez3(Nokta ilk) {
    if (gezildi[ilk]) return;
    std::queue<Nokta> kuyruk;
    kuyruk.push(ilk);
    while(not kuyruk.empty()) {
        Nokta bu = kuyruk.front();
        kuyruk.pop();
        gezildi[bu] = true;
        for (Nokta şu: komşular[bu])
            if(not gezildi[şu])
                kuyruk.push(şu);
    }
}
```

Bu üç işlev de gezmesine geziyor bütün çizgeyi ama başka da hiçbir şey yapmıyor. En basit örnek olarak noktaları sıraya sokabiliriz. Onun için her bir noktayı, gezildiğini belleğe yazdığımız yerde bir sıraya sokabiliriz:

```c++
#include <queue>
std::queue<Nokta> sıra;

// gez, gez2 ve gez3 içinde:
// ...
    gezildi[bu] = true;
    sıra.push(bu);
// ...
```

Gezinti bittikten sonra, oluşan sıralamayı şöyle yazabiliriz ekrana:
```c++
while(not sıra.empty()) {
    std::cout << sıra.front() << " ";
    sıra.pop();
}
```
[Çalışan bir örnek burada](https://onlinegdb.com/2FoVT44ev). Şu küçük çizge üzerinde üç türlü gezintinin sonunda oluşan sıraları gösteriyor:
<p align="center">
<img src="dersler/resim/yonlu-cizge1.png" alt="ufak yönlü bir çizge" width="200"/>   
</p>

Derste noktalar arasındaki uzaklıkları bulmak için `gez3()` işlevi üzerinde ufak bir değişiklik yaptık. Onun kodu da hem yukarıdaki bağlantıda hem de aşağıda var. 

Dersten sonra örnek çizgemize bir nokta (`7`) ve üç ok daha ekledim (`4 -> 7`, `5 -> 7` ve `7->5`). [Yeni kod burada](https://onlinegdb.com/1dHRbP-bY).  
<p align="center">
<img src="dersler/resim/yonlu-cizge1-arti-bir-nokta-ve-uc-ok.png" alt="oklu çizge biraz büyüdü" width="200"/>   
</p> 

Yeni örnekle çalıştırınca ufak bir hata keşfettim:

```c++
derin özyinele gezi: 1 2 5 7 3 4 6 
derin tepeyle  gezi: 1 3 4 7 5 6 2 
enine kuyrukla gezi: 1 2 3 5 4 7 6 7 

Noktalar:            1 2 3 4 5 6 7 
                     -------------
1. noktaya uzaklık:  0 1 1 2 2 3 3 
2. noktaya uzaklık:  - 0 - - 1 - 2 
3. noktaya uzaklık:  3 4 0 1 3 2 2 
4. noktaya uzaklık:  2 3 3 0 2 1 1 
5. noktaya uzaklık:  - - - - 0 - 1 
6. noktaya uzaklık:  1 2 2 3 3 0 4 
7. noktaya uzaklık:  - - - - 1 - 0 
```

Hata `gez3(Nokta)` işlevi yani enine kuyrukla gezi içinde. `7` adlı nokta sıraya iki kere girmiş! Nasıl bir mantık hatası var bulabilir misiniz? Neden derinlemesine gezilerde olmuyor? Hatayı onarmaksa çok kolay: 
```c++
void gez3(Nokta ilk) {
    if (gezildi[ilk]) return;
    std::queue<Nokta> kuyruk;
    kuyruk.push(ilk);
    while (not kuyruk.empty()) {
        Nokta bu = kuyruk.front();
        kuyruk.pop();
        // aynı nokta kuyruğa iki farklı yoldan girebilir!
        if (gezildi[bu]) continue;
        gezildi[bu] = true;
        sıra.push(bu); // burada işliyoruz
        for (Nokta şu: komşular[bu])
            if (not gezildi[şu])
                kuyruk.push(şu);
    }
}
```

Gelelim bugünkü [problemimize](https://cses.fi/problemset/task/1194/). Yine bir labirentteyiz ama bu sefer Girit adasındaki efsanevi **Minotor** labirentinden de beter çünkü birden çok canavar olabiliyor içinde. Neyseki canavarlar bizden hızlı koşamıyor. Canavarlara yakalanmadan çıkışa ulaşabilir miyiz?

İlk önemli gözlem şu: başladığımız yerden labirentin her çıkış noktasına en kısa yolu bulmamız gerek. Yoksa canavarlardan biri bizden önce oraya gidip kaçmamıza engel olabilir. Bulduğumuz en kısa yol üzerindeki her hane için de aynı koşul geçerli. 

Öte yandan en kısa yol üzerinde bir canavar olabilir. Onun için canavarların erişemeyeceği en kısa yolu bulmamız gerek. 

Görünen o ki enlemesine gezmekte fayda var. Kuyruk kullanan kalıbımız hazır. Ama nasıl kullanacağız? Ufak bir eksiklik var. Her noktanın bize ve canavarlara uzaklığını hesaplamak gerekiyor ki hangi yolun açık olduğunu bulabilelim. Onun için kalıbımızda ufak bir değişiklik yapacağız
```c++
void gez4(Nokta ilk) {
    std::queue<Nokta> kuyruk;
    kuyruk.push(ilk);
    uzaklık[ilk] = 0;
    while (not kuyruk.empty()) {
        Nokta bu = kuyruk.front();
        kuyruk.pop();
        for (Nokta şu: komşular[bu])  
            if (uzaklık[şu] == SONSUZ) {        
                kuyruk.push(şu);
                uzaklık[şu] = uzaklık[bu] + 1;
            }
        }
    }
}
```
Şu ana kadar bütün gezilerde kullandığımız `gezildi` dizisine gerek kalmadı! `uzaklık` dizisiyle bir taşla iki kuş vurduk.  Ama hangi uzaklıktan bahsediyoruz? Başlangıç noktasına olan uzaklık bize lazım ama önce büyük bir problem daha var: Canavarların büyük takımına karşı biz tek başımızayız. Büyük bir labirentte (örneğin `100x100`lük olsun), on bine yakın canavar olabilir! Problemi çözebilmek için, her karenin en yakın canavara uzaklığını bulmak gerekiyor. Nasıl yapabiliriz?

Bu noktada enlemesine gezi kalıbının gücü ortaya çıkıyor. Gezimizi tek noktadan değil, bütün canavarların bulundukları noktalardan eş zamanlı başlatabiliriz! Nasıl olacak? Epey kolay!
```c++ 
struct Nokta { K y, x; } A, B;
std::queue<Nokta> kuyruk;
for(auto canavar : canavarlar) {
    kuyruk.push(canavar);
    canavara_uzaklık[canavar.y][canavar.x] = 0;
}
while(not kuyruk.empty()) { // döngü 1
    // ... burada canavarlar kuyrukta sıraya giriyor ve bütün tahtayı dolaşarak en kısa yolların hepsini buluyorlar...
}
```
Arkadan gelen `while` döngüsü hemen hemen aynı. Döngüden çıkınca, bütün noktaların en yakın canavara uzaklığını bulmuş olacağız. Ondan sonrası da epey kolay: bu sefer `A` noktasından başlayarak bir kere daha gezeceğiz ve yeni bir `uzaklık` dizisini dolduracağız. Herhangi bir noktanın bir canavara uzaklığı bize uzaklığından azsa, tehlike yok, onun üzerinden geçebiliriz, yani kuyruğa sokabiliriz. Yok canavar aynı uzaklıkta ya da daha yakındaysa, o yol ölümcül, sakınmalı:
```c++
kuyruk.push(A);
uzaklık[A.y][A.x] = 0;
while (not kuyruk.empty()) { // döngü 2
    //... burada A'nın bütün karelere uzaklığını buluyoruz ve varsa bir çıkış yani B'yi buluyoruz 
}
```
Eğer kaçış mümkünse, ikinci döngü içinde çıkışı bulmamız gerek, yani uygun bir `B` noktası kesin bulunur. Yoksa, kuyruk boşalır, döngü biter. Yani labirent içinde nereye dönsek mümkün değil, canavarlardan birine yakalanacağız.

Bu soru hocanızı epey uğraştırdı. İlk çözümüm doğru çözse de büyük ve çok canavarlı bir iki testte 30 saniye zaman aldı! Onu [şurada](https://cses.fi/paste/cd4bda9bc7174903f9d7de/) görebilirsiniz. Ama okumadan önce kendiniz yazmayı denerseniz sizin için daha iyi olabilir. Ya da derste bahsettiğim gibi iki kişilik bir takım oyunu daha bile keyifli ve verimli olabilir. 
İngilizcede [*pair programming*](https://en.wikipedia.org/wiki/Pair_programming) derler. Biraz daha kafa yorup severek uğraşınca epey hızlandı ve yüz satırda güzel bir çözüm oldu. O da [burada](https://cses.fi/paste/53b00cbd34120c7ef9f8a2/). Gelecek derste üzerinden geçeriz inşallah.

Bu arada yapay zekaya özyineleme tekniğiyle enlemesine gezi mümkün mü diye sordum, güzel güzel anlattı. Yanıt başta İngilizce, ama onu atlayın, hemen arkasında Türkçesi var. [Buradan okuyabilirsiniz](https://share.google/aimode/DENPrTENB7hlApAbp).

Dersimizi ustalar ikiye böldü. Kusura bakmayın. Kayıtın [ilk yarısı burada](
https://drive.google.com/file/d/1H92Zgy5KsjGs_uVeNFd8Lowzwc4ox2Hk). [İkinci yarı da burada](
https://drive.google.com/file/d/1RvqqoVTpBPi5ul-E8xrOW76H1Xi2LmYS).

> [StackEdit](https://stackedit.io/) ile yazdım.
